# 多智能体协作设计和原理分析

## 概述

本文档基于 Eino 框架的源码分析，深入探讨多智能体协作场景中的上下文传递机制、设计原理和最佳实践。Eino 框架采用了分层架构设计，通过 Agent 层和 Compose 层分别处理不同的协作场景。

## 1. 框架架构设计

### 1.1 分层上下文管理

Eino 框架采用了**分层上下文管理**的设计：

- **Agent 层**：使用 `session` 管理智能体间的上下文
- **Compose 层**：使用 `state` 管理图节点的状态
- **统一接口**：都通过 `context` 传递，通过方法获取上下文

```go
// Agent 层上下文获取
func (a *flowAgent) genAgentInput(ctx context.Context, runCtx *runContext, skipTransferMessages bool) (*AgentInput, error) {
    // 从 session 获取历史事件
    events := runCtx.Session.getEvents()
    // 构建历史条目
    historyEntries := make([]*HistoryEntry, 0)
    // ...
}

// Compose 层状态管理
func (s *State) MarshalJSON() ([]byte, error) {
    // 序列化状态用于持久化
}
```

### 1.2 Agent 层 vs Compose 层设计差异

| 方面 | Agent 层 | Compose 层 |
|------|----------|------------|
| **输入输出** | 固定格式 (`AgentInput` → `AgentEvent`) | 灵活类型 (`T` → `U`) |
| **上下文传递** | 通过 `GenInputFn` 从 session 获取 | 通过类型匹配自然传递 |
| **连接方式** | 通过 `SetSubAgents` 建立父子关系 | 通过 `AddEdge` 建立图连接 |
| **状态管理** | Session 机制 | State 机制 |
| **适用场景** | 多智能体协作 | 复杂工作流编排 |

## 2. Agent 层：固定输入输出 + GenInputFn 机制

### 2.1 Agent 层的设计特点

**固定接口**：每个 Agent 都有统一的输入输出格式

```go
// Agent 接口定义
type Agent interface {
    Name(ctx context.Context) string
    Description(ctx context.Context) string
    Run(ctx context.Context, input *AgentInput, opts ...AgentRunOption) *AsyncIterator[*AgentEvent]
}

// 固定的输入格式
type AgentInput struct {
    Messages        []Message
    EnableStreaming bool
}

// 固定的输出格式
type AgentEvent struct {
    Output *AgentOutput
    Action *AgentAction
    Err    error
}
```

### 2.2 GenInputFn 机制：从 Session 获取上下文

由于 Agent 的输入输出格式是固定的，但不同 Agent 需要不同的上下文信息，所以提供了 `GenInputFn` 让每个 Agent 自定义如何从 session 中获取数据：

```go
// Executor 的 GenInputFn 示例
GenInputFn: func(ctx context.Context, in *planexecute.ExecutionContext) ([]adk.Message, error) {
    // 从执行上下文中获取信息
    planContent, err := in.Plan.MarshalJSON()
    if err != nil {
        return nil, err
    }
    
    firstStep := in.Plan.FirstStep()
    
    // 格式化消息，包含用户输入、计划、已执行步骤等
    msgs, err := executorPrompt.Format(ctx, map[string]any{
        "input":          formatInput(in.UserInput),
        "plan":           string(planContent),
        "executed_steps": formatExecutedSteps(in.ExecutedSteps),
        "step":           firstStep,
    })
    
    return msgs, nil
}
```

### 2.3 Session 机制：跨 Agent 的上下文传递

```go
// 在工具中存储和获取 session 值
func toolAFn(ctx context.Context, in *ToolAInput) (string, error) {
    // 存储到 session
    adk.AddSessionValue(ctx, "user-name", in.Name)
    return in.Name, nil
}

func toolBFn(ctx context.Context, in *ToolBInput) (string, error) {
    // 从 session 获取之前存储的值
    userName, _ := adk.GetSessionValue(ctx, "user-name")
    return fmt.Sprintf("user-name: %v, user-age: %v", userName, in.Age), nil
}
```

## 3. Compose 层：图结构 + 类型匹配

### 3.1 图结构的设计特点

**类型安全**：上一个节点的输出类型必须与下一个节点的输入类型匹配

```go
// 创建图，指定输入输出类型
g := compose.NewGraph[string, string](compose.WithGenLocalState(func(ctx context.Context) *state {
    return &state{History: []*schema.Message{}}
}))

// 添加节点，类型必须匹配
err := g.AddLambdaNode("InputConvert", 
    compose.InvokableLambda(func(ctx context.Context, input string) (output []*schema.Message, err error) {
        return []*schema.Message{
            schema.SystemMessage(systemPrompt),
            schema.UserMessage(input),
        }, nil
    }))

// 连接节点，输出类型必须匹配输入类型
err = g.AddEdge("InputConvert", "ChatModel")
```

### 3.2 自然连接：类型匹配的节点自动连接

```go
// 节点 A 输出: []*schema.Message
// 节点 B 输入: []*schema.Message
// 框架自动处理类型转换和传递

err = g.AddChatModelNode("ChatModel", cm,
    compose.WithStatePreHandler(func(ctx context.Context, in []*schema.Message, state *state) ([]*schema.Message, error) {
        // 处理输入
        state.History = append(state.History, in...)
        return state.History, nil
    }),
    compose.WithStatePostHandler(func(ctx context.Context, out *schema.Message, state *state) (*schema.Message, error) {
        // 处理输出
        state.History = append(state.History, out)
        return out, nil
    }),
)
```

## 4. 历史消息重写机制（History Rewriting）

### 4.1 核心原理

不同智能体之间传递消息时，需要添加上下文信息，避免角色混淆。

### 4.2 自定义历史重写器

```go
// 自定义历史重写器
func customHistoryRewriter(ctx context.Context, entries []*adk.HistoryEntry) ([]adk.Message, error) {
    messages := make([]adk.Message, 0, len(entries))
    
    for _, entry := range entries {
        if entry.IsUserInput {
            // 用户输入直接保留
            messages = append(messages, entry.Message)
        } else {
            // 为其他智能体的消息添加上下文
            var content string
            if entry.Message.Role == schema.Assistant {
                content = fmt.Sprintf("智能体 [%s] 说: %s", entry.AgentName, entry.Message.Content)
            } else if entry.Message.Role == schema.Tool {
                content = fmt.Sprintf("工具 [%s] 返回结果: %s", entry.AgentName, entry.Message.Content)
            }
            
            messages = append(messages, adk.Message{
                Role:    schema.User, // 重写为用户消息
                Content: content,
            })
        }
    }
    
    return messages, nil
}

// 应用历史重写器
agentWithRewriter := adk.AgentWithOptions(ctx, originalAgent, 
    adk.WithHistoryRewriter(customHistoryRewriter))
```

### 4.3 默认重写行为

```go
// 默认的历史重写逻辑
func rewriteMessage(msg Message, agentName string) Message {
    var sb strings.Builder
    sb.WriteString("For context:")
    if msg.Role == schema.Assistant {
        if msg.Content != "" {
            sb.WriteString(fmt.Sprintf(" [%s] said: %s.", agentName, msg.Content))
        }
        if len(msg.ToolCalls) > 0 {
            for i := range msg.ToolCalls {
                f := msg.ToolCalls[i].Function
                sb.WriteString(fmt.Sprintf(" [%s] called tool: `%s` with arguments: %s.",
                    agentName, f.Name, f.Arguments))
            }
        }
    } else if msg.Role == schema.Tool && msg.Content != "" {
        sb.WriteString(fmt.Sprintf(" [%s] `%s` tool returned result: %s.",
            agentName, msg.ToolName, msg.Content))
    }

    return schema.UserMessage(sb.String())
}
```

## 5. 多智能体协作的最佳实践

### 5.1 Plan-Execute-Replan 模式

```go
// 1. 规划阶段：生成计划
planAgent := planexecute.NewPlanner(ctx, &planexecute.PlannerConfig{
    ToolCallingChatModel: model.NewChatModel(),
})

// 2. 执行阶段：执行计划步骤
executeAgent := planexecute.NewExecutor(ctx, &planexecute.ExecutorConfig{
    Model: model.NewChatModel(),
    GenInputFn: func(ctx context.Context, in *planexecute.ExecutionContext) ([]adk.Message, error) {
        // 从上下文获取：用户输入、当前计划、已执行步骤
        return formatExecutorInput(in), nil
    },
})

// 3. 重规划阶段：根据执行结果调整计划
replanAgent := planexecute.NewReplanner(ctx, &planexecute.ReplannerConfig{
    ChatModel: model.NewChatModel(),
})
```

### 5.2 监督者模式

```go
// 监督者智能体
supervisor := adk.NewChatModelAgent(ctx, &adk.ChatModelAgentConfig{
    Name:        "supervisor",
    Description: "负责分配任务给专业智能体",
    Instruction: "根据任务类型选择合适的智能体",
    Model:       model.NewChatModel(),
    Exit:        &adk.ExitTool{},
})

// 专业智能体
searchAgent := adk.NewChatModelAgent(ctx, &adk.ChatModelAgentConfig{
    Name:        "searchAgent", 
    Description: "专门处理搜索相关任务",
    Model:       model.NewChatModel(),
})

// 建立监督关系
supervisorWithSubAgents, err := adk.SetSubAgents(ctx, supervisor, []adk.Agent{
    searchAgent,
    mathAgent,
    weatherAgent,
})
```

### 5.3 状态持久化和恢复

```go
// 创建带检查点的智能体
entryAgent, err := planexecute.New(ctx, &planexecute.Config{
    Planner:       planAgent,
    Executor:      executeAgent,
    Replanner:     replanAgent,
    MaxIterations: 20,
})

// 运行时指定检查点ID
result, err := runner.Invoke(ctx, input, 
    compose.WithCheckPointID("session-123"))
```

## 6. 上下文传递的关键原则

### 6.1 职责分离
- **业务智能体**：专注 AI 推理，生成 Action
- **控制层**：负责流程控制、历史管理、路径追踪

### 6.2 状态一致性
- 使用 `CheckPointStore` 确保状态持久化
- 通过 `RunPath` 追踪完整调用链
- 利用 `Session` 管理跨智能体的历史

### 6.3 消息重写
- 非用户输入的消息需要添加上下文信息
- 避免角色混淆，确保每个智能体理解消息来源
- 支持自定义历史重写器

### 6.4 错误处理
- Transfer 失败时返回明确错误
- 支持中断和恢复机制
- 提供完整的调用链追踪

## 7. 实际应用建议

### 7.1 合理设计智能体描述
Description 是模型路由决策的关键依据：

```go
// ❌ 不好：描述不清晰
Description: "This is an agent."

// ✅ 好：清晰说明职责和能力
Description: "This agent can get the current weather for a given city."
```

### 7.2 避免循环 Transfer
设计清晰的层级关系：

```go
// ❌ 不好：AgentA 和 AgentB 互为子 Agent
adk.SetSubAgents(ctx, agentA, []adk.Agent{agentB})
adk.SetSubAgents(ctx, agentB, []adk.Agent{agentA})

// ✅ 好：清晰的层级关系
adk.SetSubAgents(ctx, supervisor, []adk.Agent{agentA, agentB})
```

### 7.3 使用 Exit 工具明确结束
RouterAgent 应该配置 `Exit` 工具，明确告知模型何时结束对话：

```go
agent, _ := adk.NewChatModelAgent(ctx, &adk.ChatModelAgentConfig{
    Name:        "RouterAgent",
    Description: "A router that transfers tasks to other agents.",
    Exit:        &adk.ExitTool{},  // ← 添加 exit 工具
})
```

### 7.4 利用 RunPath 追踪调用链
在生产环境中，记录 `event.RunPath` 用于调试和分析：

```go
for {
    event, ok := iter.Next()
    if !ok {
        break
    }
    
    // 记录完整调用链
    log.Printf("Agent: %s, RunPath: %v, Action: %v", 
        event.AgentName, event.RunPath, event.Action)
}
```

## 8. 总结

Eino 框架通过**分层架构设计**实现了多智能体协作的优雅解决方案：

### 8.1 Agent 层特点
- **固定接口**：统一的输入输出格式，简化智能体实现
- **GenInputFn 机制**：允许每个智能体自定义上下文获取逻辑
- **Session 管理**：跨智能体的状态共享和传递

### 8.2 Compose 层特点
- **类型安全**：编译时确保节点间类型匹配
- **自然连接**：通过类型系统实现节点间的自动连接
- **状态管理**：图级别的状态持久化和恢复

### 8.3 设计优势
- **可扩展性**：新增智能体只需实现 `Agent` 接口
- **可组合性**：支持任意层级的嵌套和组合
- **可观测性**：完整的调用链追踪和事件流
- **灵活性**：支持自定义历史重写和状态管理

这套机制通过**声明式关系管理**、**自动工具注入**、**智能历史重写**等特性，实现了多智能体间的优雅协作，大大简化了复杂多智能体系统的开发难度。
